-----------------------------------------------------------
CHAPTER 4 - CREATING & MANAGING CONTAINER IMAGES
-----------------------------------------------------------

- What Are Images?

    - In Linux, everything is a file.  The whole OS is basically a filesystem with files and
        folders stored on the local disk.  

      An 'image' is basically a big tarball containing a layered filesystem.



- The Layered Filesystem

    - Container images are templates from which containers are created.  They are not just one
        monolithic block, but are rather composed of many layers.

                     Layer n
                     Layer n-1
                     ...
                     Layer 2
                     Layer 1 (Base Layer)


    - Each individual layer contains files and folders.  Each layer contains only the
        filesystem with respect to the underlying layers.  Docker then uses a union 
        filesystem to create a virtual filesystem out of the set of layers.

      A storage driver handles the details regarding the way these layers interact with
        each other.  Different storage drivers are available that have advantages and
        disadvantages in different situations.


    - The layers of a container image are all immutable.  Once they are generated, they
        cannot be changed.  The only possible operation affecting a layer is the 
        physical deletion of it.

      Since the layers are immuatable, they can be cached without ever becoming stale, 
        which leads to big performance advantages.


    - Here is an example image:

        3. Add static files (ie HTML, CSS, JS files)
        2. Add Nginx
        1. Alpine Linux

      Each layer contains only the delta of changes in regard to the previous set of
        layers.  The content of each layer is mapped to a special folder on the host
        system (usually a subdirectory of /var/lib/docker).


    - The base image is typically one of the official images found on Docker Hub, like
        Alpine, Ubuntu, or CentOS.  It is also possible to create an image from scratch.

      Docker Hub is a public registry for container images.  It is a central hub ideally
        suited for sharing public container images.



- The Writable Container Layer

    - When the Docker engine creates a container from an image, it adds a writable container
        layer on top of the stack of immuatable layers.

        Container Layer    r/w
        3. Add static files
        2. Add Nginx
        1. Alpine Linux


    - Another advantage of the layered approach is that image layers can be shared among many
        containers created from an image.  All that is needed is a thin, writable container
        layer for each container.

        Container1          Container2         Container3
        Thin r/w layer      Thin r/w layer     Thin r/w layer
                   \              |                /
                    \             |               /
                     \            |              /
                         3. Add static files
                         2. Add Nginx
                         1. Alpine Linux



- Copy-on-Write

    - Docker uses a copy-on-write technique when dealing with images.  If a layer needs a 
        file or folder on a lower layer, it just uses it.  If a layer needs to write to 
        a file in a lower layer, it first copies the file to the target layer, then
        modifies it.



- Graph Drivers

    - Graph drivers (aka storage drivers) are what enable the union filesystem.  A graph
        driver consolidates the multiple image layers into a root filesystem for the mount
        namespace of the container.

      To put it differently, the driver controls how images and containers are stored and
        managed on the Docker host.


    - Docker supports several different graph drivers using a pluggable architecture.  The
        preferred driver is 'overlay2', followed by 'overlay'.



- Creating Images

    - There are 3 ways to create a new container image on your system:

        1. Interactively build a container that contains all the additions and changes
             one desires and then commit those changes onto a new image.

        2. Use a Dockerfile to describe what's in the new image and then build this image
             using the Dockerfile as a manifest (this way is the most important).

        3. Import it into the system from a tarball.



- Interactive Image Creation

    - To create an image interactively, we start with a base image we want to use as a
        template and run it as a container interactively.

        # Run an alpine container interactively
        $ docker container run -it --name sample alpine bin/sh


        # Install ping command on image
        $ apk update && apk add iputils

        # Now we can use ping
        $ ping 127.0.0.1


    - Now, we can quit the container ('exit') and list all the containers on the system:

        # Container has exited
        $ docker container ls -a | grep sample

        eff7c92a1b98    alpine    "/bin/sh"    2 minutes ago      Exited (0) ...


    - To see what has changed in our container in relation to the base image, we can use the
        'container diff' command.

        # See changes from base image
        $ docker container diff sample

        # A for added, C for changed
        C /bin
        C /bin/ping
        C /bin/ping6
        A /bin/traceroute6


    - We can now use the 'container commit' command to persist the changes and create a
        new image from them.

        # Create new image 'my-alpine'
        $ docker container commit sample my-alpine


        # See new image on the system 
        #   (note that 'latest' is default tag)
        $ docker image ls

        REPOSITORY TAG      IMAGE ID        CREATED               SIZE
        my-alpine  latest   44bca4141130    About a minute ago    5.64MB
        ...


    - To get the list of layers our image consists of:

        # Print list of layers
        $ docker image history my-alpine



- Using Dockerfiles

    - Dockerfiles provide a declarative way of building images.  For instance, here is a
        Dockerfile used to containerize a Python 2.7 application.

        # Dockerfile
        FROM python:2.7                         # Layer 1 (Base Layer)
        RUN mkdir -p /app                       # Layer 2
        WORKDIR /app                            # Layer 3
        COPY ./requirements.txt /app/           # Layer 4
        RUN pip install -r requirements.txt     # Layer 5
        CMD ["python", "main.py"]               # Layer 6


      Each line of the Dockerfile results in a layer in the resulting image.  



- The FROM Keyword

    - Every Dockerfile starts with the 'FROM' keyword.  With it, we define which base image
        we want to start building our custom image from.

        # Build starting from Centos 7
        FROM centos:7

        # Build starting from official Python 2.7 image
        FROM python:2.7

        # Build starting from scratch
        FROM scratch



- The RUN Keyword

    - The argument for the 'RUN' keyword is any valid Linux command.

        # Install wget on Centos
        RUN yum install -y wget

        # Install wget on Ubuntu
        RUN apt-get update && apt-get install -y wget


        # Make a directory and navigate to it
        RUN mkdir -p /app && cd /app

        # Untar a file to new directory
        RUN tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz


        # We can also use multiline Linux commands
        RUN apt-get update \
          && apt-get install -y --no-install-recommends \
            ca-certificates \
            libexpat1 \
            libffi6 \
            libgdbm3 \
            libreadline7 \
            libsqlite3-0 \
            libssl1.1 \
          && rm -rf /var/lib/apt/lists/*



- The COPY and ADD Keywords

    - The 'COPY' and 'ADD' keywords are used to add some content to a base image.  Most 
        of the time, these are source files (ie from a web application) or binaries
        (from a compiled application).


    - Both keywords are used to copy files and folders from the host onto the image that 
        we're building.  They are very similar, except ADD also lets us copy and unpack
        TAR files, as well as provide a URL as a source for files and folders to copy.


        # Copy all files and folders in current dir to /app folder in container image
        COPY . /app

        # Copy everything in /web subfolder to /app/web in container image
        COPY ./web /app/web

        # Copy a single file into target folder and rename it
        COPY sample.txt /data/my-sample.txt


        # Unpack the tar file to the target folder
        ADD sample.tar /app/bin/

        # Copy remote file into target file
        ADD http://example.com/sample.txt /data/


    - Wildcards are allowed in the source path.

        # Copy all files starting with 'sample'
        COPY ./sample* /mydir/


    - By default, all files and folders inside the image will have a UID and GID of 0.
        For both the ADD and COPY commands, we can change the ownership using the 
        '--chown' flag.

        # Assigns UID of 11, GID of 22 to files added
        ADD --chown=11:22 ./data/files* /app/data/



- The WORKDIR Keyword

    - The 'WORKDIR' keyword defines the working dirctory or context that is used when a 
        container is run from our custom image.  All activity that happens after this
        statement will use this directory as the working directory.


        # This creates a file in /app/bin
        RUN cd /app/bin
        RUN touch sample.txt

        # Same, but sets the context across the layers of the image
        WORKDIR /app/bin
        RUN touch sample.txt



- The CMD and ENTRYPOINT Keywords

    - The CMD and ENTRYPOINT keywords are special.  While all other keywords defined for a
        Dockerfile are executed at the time the image is built by the Docker builder, 
        these keywords are actually deifinitions of what will happen when the container is
        started.

      When the container runtime starts a container, it needs to know what the process or
        application is that will be run inside the container.  CMD and ENTRYPOINT are used
        to tell Docker what the start process is and how to start that process.


    - To understand 2 keywords, look at this linux command:

        # Linux command
        $ ping 8.8.8.8 -c 3


      The ENTRYPOINT keyword defines the command to be run and the CMD keyword defines the
        parameters for the command.

        # Dockerfile
        FROM alpine:latest
        ENTRYPOINT ["ping"]
        CMD ["8.8.8.8", "-c", 3]


    - For both ENTRYPOINT and CMD, the values are formatted as a JSON array of strings,
        where the individual items correspond to the tokens of the expressions (separated
        by whitespace).  This is called the 'exec form', and is the preferred way of
        dealing with ENTRYPOINT and CMD.

      Alternatively, we can use the 'shell form':

          CMD command param1 param2


    - Now we can build an image from the Dockerfile we just created and run it:

        # Build pinger image
        $ docker image build -t pinger .

        # Run container from pinger image
        $ docker container run --rm -it pinger


    - To override the CMD and ENTRYPOINT options specified:

        # Override the CMD arguments from the Dockerfile
        $ docker container run --rm -it pinger -w 5 127.0.0.1

        # Override the ENTRYPOINT
        $ docker container run --rm -it --entrypoint /bin/sh pinger


    - Note that again, we can just put the entire command into a CMD statement, but this is
        not recommended.

        # Put entire command expression in CMD
        FROM alpine:latest
        CMD wget -O - http://www.google.com



- A Complex Dockerfile

- Building an Image

- Multistep Builds

- Dockerfile Best Practices

- Saving and Loading Images

- Sharing or Shipping Images

- Tagging an Image

- Image Namespaces

- Official Images

- Pushing Images to a Registry