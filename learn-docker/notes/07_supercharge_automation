-----------------------------------------------------------
CHAPTER 7 - USING DOCKER TO SUPERCHARGE AUTOMATION
-----------------------------------------------------------

- Executing Simple Admin Tasks in a Container

    - Let's assume we have a handy Perl script to strip all whitespace from a file.

        $ cat sample.txt | perl -lpe 's/^\s*//'


    - The only problem is that we don't have Perl installed on our machine.  But, we can
        use Docker to circumvent the need to install it.

        1. Create a new folder

             $ mkdir -p ~/fod/ch07/simple-task && cd ~/fod/ch07/simple-task


        2. Create a sample file in the new folder

             # File: sample.txt

             1234567890
               This is some text
                another line of text
              more text
                  final line


        3. Now, we can run a container with Perl installed in it.  We use the slim version
             of the official Perl image.

           We map the current working directory on our host to /usr/src/app in the container,
             and set /usr/src/app to be the container's working directory.


             # Run Perl script on our files without installing Perl
             $ docker container run --rm -it \
                                    -v $(pwd):/usr/src/app \
                                    -w /usr/src/app \
                                    perl:slim sh -c "cat sample.txt | perl -lpe 's/^\s*//'"


    - Note that we could even use some older version of Perl if we needed to.  

        perl:some-old-version


    - On hosts that don't have Python 3 installed, we can use this same technique to run
        Python 3 scripts.

        python:3.7.4-alpine python stats.py sample.txt



- Using Test Containers

    - Typical Test Types:

        1. Unit Tests
             Assert the correctness and quality of an individual, isolated piece of the 
               overall application.  

        2. Integration Tests
             Makes sure that pieces that are closely related work together as expected.

        3. Stress and Load Tests
             Tests the behavior of the application when handling lots of current requests
               and large amounts of data.

        4. End-to-End Tests
             Simulate a real user working with the application.


    - The code or component under test is often called a SUT (System Under Test).

      Unit tests are tightly coupled to the actual code, so they live in the same container
        as the SUT.  Integration, stress/load, and end-to-end tests use the public interface
        of the application, so they often run from a separate container.


    - End-to-end tests often use the Selenium web driver to automate actions on a given web
        page.



- Integration Testing a Node.js Application

    1. Make a folder and subfolders for our application.  The subfolders are 'tests', 'api',
         and 'database'.

        $ mkdir ~/fod/ch07/integration-test-node && cd ~/fod/ch07/integration-test-node
        $ mkdir tests api database


    2. Create the script to initialize the database.  We will use it to create the Postgres
         database.

        # File: integration-test-node/database/init-script.sql

        CREATE TABLE hobbies(
           hobby_id serial PRIMARY KEY,
           hobby VARCHAR (255) UNIQUE NOT NULL
        );
        
        insert into hobbies(hobby) values('swimming');
        insert into hobbies(hobby) values('diving');
        insert into hobbies(hobby) values('jogging');
        insert into hobbies(hobby) values('dancing');
        insert into hobbies(hobby) values('cooking');



- The Testcontainers Project


- Using Docker to Power a CI/CD Pipeline