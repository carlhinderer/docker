-----------------------------------------------------------
CHAPTER 7 - USING DOCKER TO SUPERCHARGE AUTOMATION
-----------------------------------------------------------

- Executing Simple Admin Tasks in a Container

    - Let's assume we have a handy Perl script to strip all whitespace from a file.

        $ cat sample.txt | perl -lpe 's/^\s*//'


    - The only problem is that we don't have Perl installed on our machine.  But, we can
        use Docker to circumvent the need to install it.

        1. Create a new folder

             $ mkdir -p ~/fod/ch07/simple-task && cd ~/fod/ch07/simple-task


        2. Create a sample file in the new folder

             # File: sample.txt

             1234567890
               This is some text
                another line of text
              more text
                  final line


        3. Now, we can run a container with Perl installed in it.  We use the slim version
             of the official Perl image.

           We map the current working directory on our host to /usr/src/app in the container,
             and set /usr/src/app to be the container's working directory.


             # Run Perl script on our files without installing Perl
             $ docker container run --rm -it \
                                    -v $(pwd):/usr/src/app \
                                    -w /usr/src/app \
                                    perl:slim sh -c "cat sample.txt | perl -lpe 's/^\s*//'"


    - Note that we could even use some older version of Perl if we needed to.  

        perl:some-old-version


    - On hosts that don't have Python 3 installed, we can use this same technique to run
        Python 3 scripts.

        python:3.7.4-alpine python stats.py sample.txt



- Using Test Containers

    - Typical Test Types:

        1. Unit Tests
             Assert the correctness and quality of an individual, isolated piece of the 
               overall application.  

        2. Integration Tests
             Makes sure that pieces that are closely related work together as expected.

        3. Stress and Load Tests
             Tests the behavior of the application when handling lots of current requests
               and large amounts of data.

        4. End-to-End Tests
             Simulate a real user working with the application.


    - The code or component under test is often called a SUT (System Under Test).

      Unit tests are tightly coupled to the actual code, so they live in the same container
        as the SUT.  Integration, stress/load, and end-to-end tests use the public interface
        of the application, so they often run from a separate container.


    - End-to-end tests often use the Selenium web driver to automate actions on a given web
        page.



- Integration Testing a Node.js Application - Preparing the Database

    1. Make a folder and subfolders for our application.  The subfolders are 'tests', 'api',
         and 'database'.

        $ mkdir ~/fod/ch07/integration-test-node && cd ~/fod/ch07/integration-test-node
        $ mkdir tests api database


    2. Create the script to initialize the database.  We will use it to create the Postgres
         database.

        # File: integration-test-node/database/init-script.sql

        CREATE TABLE hobbies(
           hobby_id serial PRIMARY KEY,
           hobby VARCHAR (255) UNIQUE NOT NULL
        );
        
        insert into hobbies(hobby) values('swimming');
        insert into hobbies(hobby) values('diving');
        insert into hobbies(hobby) values('jogging');
        insert into hobbies(hobby) values('dancing');
        insert into hobbies(hobby) values('cooking');


    3. Create a volume where the database will store it's files.

        $ docker volume create pg-data


    4. Run the database container.

        $ docker container run -d \
                               --name postgres \
                               -p 5432:5432 \
                               -v $(pwd)/database:/docker-entrypoint-initdb.d \
                               -v pg-data:/var/lib/postgresql/data \
                               -e POSTGRES_USER=dbuser \
                               -e POSTGRES_DB=sample-db \
                               postgres:11.5-alpine


    5. Verify that the new container is running.  We will see that the initialization
         script was run.

         $ docker container logs postgres

         ...
         server started
         CREATE DATABASE
         
         /usr/local/bin/docker-entrypoint.sh: running /docker-entrypoint-initdb.d/init-db.sql
         CREATE TABLE
         INSERT 0 1
         INSERT 0 1
         INSERT 0 1
         INSERT 0 1
         INSERT 0 1
         
         ...
         
         PostgreSQL init process complete; ready for start up.
         
         2019-09-07 17:22:30.056 UTC [1] LOG: listening on IPv4 address "0.0.0.0", port 5432
         ...



- Integration Testing a Node.js Application - Building the API

    1. Initialize the API project.

        $ cd api
        $ npm init


    2. Add a start command to the package.json.

        # File: package.json

        "scripts": {
          "start": "node index.js",
          "test": "echo \"Error: no test specified\" && exit 1"
        },


    3. Add Express JS.

        $ npm install express --save


    4. Create a 'server.js' file in the 'api' folder.

        # File: api/server.js

        const express = require('express');
        const app = express();

        app.listen(3000, '0.0.0.0', () => {
            console.log('Application listening at 0.0.0.0:3000');
        })

        app.get('/', (req, res) => {
            res.send('Sample API');
        })


    5. Start the app and test the home endpoint.

        # Start the app
        $ npm start

        # Test the home endpoint
        $ curl localhost:3000



- The Testcontainers Project


- Using Docker to Power a CI/CD Pipeline