---------------------------------------------------------------------
CHAPTER 2 - PYTHON REST SERVICE
---------------------------------------------------------------------

- Analyzing the Thoughts Backend Microservice

    - This is the diagram we created in the last chapter:


                                          ---> static
                                         /
                                        /----> Users backend ---------\
         Client  <--->  Load Balancer --                                DB
                                        \----> Thoughts backend ------/
                                         \
                                          ---> HTML frontent



- Understanding the Security Layer

    - Since the Thoughts backend is going to be availability externally, we need to implement
        a security layer.  We need to identify the user producing the actions and verify
        their validity.


    - This security layer will come in the shape of a header.  This header will contain 
        information that is signed by the users backend, verifying its origin.  It will be a
        JWT (JSON Web Token), which is standard for this purpose.

      A JWT is not the only possibility for the token.  There are other alternatives such as 
        storing the equivalent data in a session cookie or using similar modules such as PASETO.


    - This method should be handled by the Users Backend team, and get packages so that the
        other microservices can use it.  For this chapter, we'll include it in the Thoughts
        Backend, but later we'll move it to the Users Backend.


    - If the requests don't have a valid header, the API will return a 401 Unauthorized status
        code.



- Desiging the RESTful API

    - We will use RESTful design for our API, which means we will construct URIs that
        represent resources and then use HTTP methods to perform actions on these resources.

        Http Methods
        ----------------
        GET      retrieve
        POST     create
        DELETE   delete
        PUT      overwrite completely
        PATCH    partial update


    - With RESTful APIs, requests need to be stateless, so each request is totally self-contained
        and can be served by any server.  All required data should either be at the client or
        in the database.  This is a hard requirement for Docker containers.


    - It is common to have resources that map directly to database tables, but this is not 
        necessary.  Resources can be compositions or aggregations of different tables also.  The
        database schema should not constrain our service APIs.



- Specifying the API Endpoints

    - Here is our API interface:

        Method      Endpoint             Requires            Returns
                                         Authentication
        -----------------------------------------------------------------------------------
        GET     /api/me/thoughts           Yes               List of thoughts for the user

        POST    /api/me/thoughts           Yes               The newly created thought

        GET     /api/thoughts              No                List of all thoughts

        GET     /api/thoughts/X/           No                The thought with id X

        GET     /api/thoughts/?search=X    No                Search all thoughts that contain X

        DELETE  /admin/thoughts/X/         No                Deletes thought with id X



    - Note that there are 2 elements of the API:

        1. A public api, starting with /api

            - An authenticated public API, starting with /api/me.  The user needs to be
                authenticated to perform these actions.  A non-authenticated request 
                will return a '401 Unauthorized'.

            - A non-authenticated public api, starting with /api.  Any user can perform
                these actions, even if they are not authenticated.


        2. An admin api, starting with /admin

            - This won't be exposed publicly.  It allows you to do operations that are not
                designed to be done by customers.



    - The format of a thought is:

        thought
        {
            id integer
            username string
            text string
            timestamp string($date-time)
        }

        - To create one, only the text needs to be sent.  The timestamp and id are created
            automatically, and the username is detected by the authentication data.


    - There is some debate over whether it's best to end URIs with a final slash or not.  When
        working with Flask, defining them with a slash will cause requests without a slash to
        return a '308 Permanent Redirect'.  In any case, we should be consistent to avoid
        confusion.



- Defining the Database Schema

    - The database schema is simple and inherited from the monolith.  For the moment, we're
        only worried about the thoughts table.


        Field     Type                   Comments
        --------------------------------------------------------
        id         INTEGER NOT NULL      Primary key

        username   VARCHAR(50)

        text       VARCHAR(250)

        timestamp  DATETIME              Creation time



    - This table is represented in code in the 'thoughts_backend/models.py' file, described in
        SQLAlchemy format with the following code:


        class ThoughtModel(db.Model):
            id = db.Column(db.Integer, primary_key+true)
            username = db.Column(db.String(50))
            text = db.Column(db.String(250))
            timestamp = db.Column(db.DateTime, server_default=func.now())


      SQLAlchemy is capable of creating the table for testing purposes or for development mode.
        In this chapter, we will use SQLite as the database.



- Working with SQLAlchemy

    - SQLAlchemy is a powerful Python ORM.  It abstracts database access using Python objects.
        It is quite flexible and has functionality for working close to the database or with
        more layers of abstraction.


    - After we define a model, we can perform a query by using the 'query' attribute and
        filtering accordingly.

        # Retrive a single thought by its primary key
        thought = ThoughtModel.query.get(thought_id)

        # Retrieve all thoughts filtered by a username
        thoughts = ThoughtModel.query.
                                filter_by(username=username).
                                order_by('id').
                                all()


    - Storing and deleting a row requires the use of the session and then committing it.

        # Create a new thought
        new_thought = ThoughtModel(username=username, text=text, timestamp=datetime.utcnow())
        db.session.add(new_thought)
        db.session.commit()

        # Retrieve and delete a thought
        thought = ThoughtModel.query.get(thought_id)
        db.session.delete(thought)
        db.session.commit()


    - We configure database access in the 'thoughts_backend/db.py' file.



- Flask-RESTPlus

- Handling Resources

- Parsing Input Parameters

- Serializing Results

- Performing the Action

- Authenticating the Requests

- Defining the pytest Fixtures

- Understanding test_token_validation.py